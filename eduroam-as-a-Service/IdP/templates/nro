server %(nro)s {
listen {
	type = auth
	# ipv4addr = *
	# ipv6addr = *
	ipaddr = 127.0.0.1
	port = %(port_auth)s
	limit {
	      max_connections = 16
	      lifetime = 0
	      idle_timeout = 30
	}
}

listen {
	ipaddr = *
#	ipv6addr = ::
	port = %(port_acct)s
	type = acct
	limit {
	}
}

authorize {
	filter_username
	preprocess
#	operator-name
#	cui
	auth_log
	suffix
	if (Realm =~ /(.*\.)*%(escaped_realm)s/) {
		eap_%(nro)s {
			ok = return
		}
	}
	files
#	daily
	expiration
	logintime
}


authenticate {
	eap_%(nro)s
}


preacct {
	preprocess
	acct_unique
	suffix
	files
}

accounting {
#	cui
	detail
#	daily
	unix
	-sql
#	sql_log
	exec
	attr_filter.accounting_response
}


session {
#	radutmp
	#  See "Simultaneous Use Checking Queries" in mods-available/sql
#	sql
}


post-auth {
	update {
		&reply: += &session-state:
	}
#	cui
#	reply_log
	-sql
#	sql_log
	exec
	remove_reply_message_if_eap
	Post-Auth-Type REJECT {
		-sql
		attr_filter.access_reject
		eap_%(nro)s
		remove_reply_message_if_eap
	}
}

pre-proxy {
#	operator-name
#	cui
#	files
}

post-proxy {
	eap_%(nro)s
}
}
